
#include <iostream>
#include <cmath>
#include <vector>

const int searchLimit = 50000000;
const int primeSearchLimit = pow(searchLimit, 0.5);

std::vector<int> primeVec(int limit)
{
	//creates the vector that will contain the primes
	//also creates the bool array which states if a number is prime
	//the memset function sets the whole array to true as a starting point
	std::vector<int> placeHolderVec;
	bool prime[primeSearchLimit + 1];
	memset(prime, true, sizeof(prime));

	for (int p = 2; p*p <= limit; p++)
	{
		//if prime[p] is not changed, it is true;

		if (prime[p] == true)
		{


			//update all the multiples of p greater than or equal to the square of it.
			//numbers which are multiple of p and are less than p*p are already marked.
			for (int i = p * p; i <= limit; i += p)
			{
				prime[i] = false;
			}

		}

	}
	//after the prime array is correct this loop then adds the prime numbers to the prime number vector.
	for (int p = 2; p <= limit; p++)
	{
		if (prime[p])
		{
			placeHolderVec.push_back(p);
		//	std::cout << p << " ";
		}
			
	}

  //  std::cout << placeHolderVec.size();
	//returns the final vector containing all the primes
	return placeHolderVec;

}

int searchSolutions(std::vector<int> primes)
{
    int solutionCount = 0;
    std::vector<int> primeVector = primes;
    for(int i = 0; i <= primeVector.size(); i++)
    {
        for(int j = 0; j <= primeVector.size(); j++)
        {

            for(int n = 0; n <= primeVector.size(); n++)
                {
                        if((pow(primeVector[n],2)+pow(primeVector[j], 3) +pow(primeVector[i], 4)) < searchLimit)
                            solutionCount++;
                }
        }

    }


    std::cout << solutionCount;
    return 1;



}



int main() 
{

searchSolutions(primeVec(primeSearchLimit));


}
